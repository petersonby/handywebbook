# JavaScript

Ответы на вопросы с собеседований по JavaScript.  
Простые ответы на сложные (и не очень) вопросы.  
Да-да, это повторение mdn, спецификаций, и статьи, что вы когда-то читали, ничего нового.

## Оглавление
- [DOM](#dom)
- [Типы данных](#типы-данных)
- [Контекст выполнения](#контекст-выполнения)
- [Замыкания](#замыкания)
- [Async/defer атрибуты](#asyncdefer-атрибуты)
- [Прототипы](#прототипы)
- [Классы](#классы)
- [Promises](#promises)
- [Async / Await](#async--await)
- [Node.js, NPM](#nodejs-npm)
- [Event Loop](#event-loop)
- Express.js
- REST API
- NOSQL Databases (mongodb)
- Postgresql
- Микросервисы
- JS Doc
- Тестирование (UNIT, etc)
- Протоколы HTTP, HTTPS
- Docker
- [React](#react)
- [Props](#props)
– [State](#state)
- React Hooks
- Lifecycle
- Context
- Fragment
- Refs
- Redux

## Вопросы и ответы

### DOM
_DOM_ («Document Object Model» – Объектная модель документа) – способ представления веб-страницы в виде структуры тегов наподобие дерева. Каждый _html-элемент_, а также _текстовый узел_ является __объектом__. Пробелы и переводы строки – это полноправные символы, они образуют текстовые узлы и становятся частью дерева _DOM_.  Кроме того, даже объект `document`, представляющий весь документ, формально является DOM-узлом. 

По существу, __DOM__ соединяет веб-страницу с языками описания сценариев либо языками программирования.
Посмотреть вживую на структуру __DOM__ _(с некоторыми оговорками)_ можно в «инструментах разработчика» вашего браузера.

Существует __12 типов узлов__. Но на практике мы в основном работаем с __4 из них__:
- `document` – «входная точка» в DOM.
- __узлы-элементы__ – HTML-теги, основные строительные блоки.
- __текстовые узлы__ – содержат текст.
- __комментарии__ – иногда в них можно включить информацию, которая не будет показана на странице, но доступна в DOM для чтения JS.

[Вернуться к оглавлению](#оглавление)

### Типы данных

В JavaScript существует __7 типов__ данных: __6 примитивных__ и __object__.

Примитивные типы данных:  
1. Number (Число)

    В JS имеется только один тип данных для целых чисел и чисел с плавающей точкой. Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: `Infinity`, `-Infinity` и `NaN`:  
    `Infinity` – бесконечность ∞. Это особое значение, которое больше любого числа.

    Мы можем получить его в результате деления на ноль:
    ```JavaScript
    console.log( 1 / 0 ); // Infinity
    ```
    Или задать его явно:
    ```JavaScript
    console.log( Infinity ); // Infinity
    ```
    
    `NaN` означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:
    ```JavaScript
    console.log( "строка" / 2 ); // NaN
    ```
2. String (Строка)

    В JavaScript существует три типа кавычек:
    - Двойные кавычки: `"Привет"`.
    - Одинарные кавычки: `'Привет'`.
    - Обратные кавычки: `` `Привет` ``. Они имеют «расширенный функционал». Они позволяют нам встраивать выражения в строку, заключая их в `${…}`. Например:
    
    ```JavaScript
    let age = 5;
    
    let me = `Меня зовут Вася, мне ${age} лет.` // Меня зовут Вася, мне 5 лет.
    
    ```
3. Boolean (Булевый или логический)

    _Булевый тип_ может принимать только два значения: `true` (истина) и `false` (ложь).
4. Null
5. Undefined
6. Symbol (Символ)

[Вернуться к оглавлению](#оглавление)

### Контекст выполнения

_Контекст выполнения (execution context)_ – специальная внутренняя структура данных, которая содержит информацию о вызове функции. Она включает в себя конкретное место в коде, на котором находится интерпретатор, локальные переменные функции, значение `this` и прочую служебную информацию.

Один вызов функции имеет ровно один контекст выполнения, связанный с ним.

Когда функция производит вложенный вызов, происходит следующее:

1. Выполнение текущей функции приостанавливается.
2. Контекст выполнения, связанный с ней, _запоминается_ в специальной структуре данных – _стеке контекстов выполнения (execution stack)_ (его же называют _стеком вызовов (call stack)_).
3. Выполняются _вложенные вызовы_, для каждого из которых _создаётся свой_ __контекст выполнения_.
4. После их завершения _старый контекст достаётся из стека_, и выполнение внешней функции возобновляется с того места, где она была остановлена.

[Вернуться к оглавлению](#оглавление)

### Замыкания

_Замыкание (closure)_ – функция вместе со своим внешним окружением.

В случае _JavaScript_ правильным ответом на вопрос о том, что такое замыкание, будет _определение_ замыкания и объяснение того факта, что _все функции в JavaScript являются замыканиями_, а также рассказ о свойстве `[[Environment]]` и о том, как работает __лексическое окружение__.

Тема замыканий тесно связана с темой _лексического окружения_, о нём будет рассказ подробнее позже.
Все функции «при рождении» получают скрытое свойство `[[Environment]]`, которое ссылается на _лексическое окружение_ места, где они были созданы.

```JavaScript
function makeCounter() {
  let count = 0;

  return function() {
    return count++; // есть доступ к внешней переменной "count"
  };
}

let counter = makeCounter();
let counter2 = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter2() ); // 0
alert( counter2() ); // 1
```

[Вернуться к оглавлению](#оглавление)

### Async/defer атрибуты

Атрибуты `async` и `defer` добавляются к тегу `<script src="">`, при этом их действие не распространяется на содержимое тега `<script>`, т.е. они __работают только для внешних файлов__ скриптов.

#### defer
Атрибут `defer` сообщает браузеру, что тот должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда он загрузится.

```HTML
<script defer src=""></script>
```

- Содержимое страницы отобразится мгновенно.  
- Скрипты с defer никогда не блокируют страницу.  
- Скрипты с defer всегда выполняются, когда дерево DOM готово, но до события `DOMContentLoaded`.  
- Событие `DOMContentLoaded` подождёт отложенный скрипт. Оно будет сгенерировано, только когда скрипт с атрибутом `defer` будет загружен и выполнен.
- Отложенные с помощью `defer` скрипты сохраняют порядок относительно друг друга, как и обычные скрипты. Поэтому, если сначала загружается большой скрипт, а затем меньшего размера, то последний будет ждать.

#### async

Атрибут `async` означает, что скрипт абсолютно независим:

- Страница _не ждёт_ асинхронных скриптов, содержимое обрабатывается и отображается.
- Событие `DOMContentLoaded` и асинхронные скрипты не ждут друг друга: `DOMContentLoaded` может произойти как до, так и после асинхронного скрипта
- Остальные скрипты не ждут `async`, и скрипты c `async` не ждут другие скрипты. Так что если есть несколько скриптов с `async`, они могут выполняться в любом порядке. То, что первое загрузится – запустится в первую очередь.

```HTML
<script async src=""></script>
```

Асинхронные скрипты полезны для добавления на страницу сторонних скриптов: счётчиков, рекламы и прочего, поскольку они не зависят от внутренних скриптов сайта.

[Вернуться к оглавлению](#оглавление)

### Прототипы

В JavaScript объекты имеют специальное скрытое свойство `[[Prototype]]` (так оно названо в спецификации), которое либо равно `null`, либо ссылается на другой объект. Этот объект называется «прототип».
Когда мы хотим прочитать свойство из object, а оно отсутствует, JavaScript автоматически берёт его из прототипа. Это называется «прототипным наследованием».

Свойство `[[Prototype]]` является внутренним и скрытым, но есть много способов задать его.

Одним из них является использование `__proto__`, например так:

```JavaScript
let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal; // (*)

// теперь мы можем найти оба свойства в rabbit:
alert( rabbit.eats ); // true (**)
alert( rabbit.jumps ); // true
```

Прототип используется только для чтения свойств.

Операции записи/удаления работают напрямую с объектом.

Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.

Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода `obj.hasOwnProperty(key)`: он возвращает `true`, если у obj есть собственное, не унаследованное, свойство с именем `key`.

```JavaScript
for(let prop in rabbit) {
  let isOwn = rabbit.hasOwnProperty(prop);

  if (isOwn) {
    alert(`Our: ${prop}`); // Our: jumps
  } else {
    alert(`Inherited: ${prop}`); // Inherited: eats
  }
}
```

Новые объекты могут быть созданы с помощью функции-конструктора `new F()`.

Если в `F.prototype` содержится объект, оператор new устанавливает его в качестве `[[Prototype]]` для нового объекта.

У каждой функции по умолчанию уже есть свойство "prototype".

По умолчанию "prototype" – объект с единственным свойством constructor, которое ссылается на функцию-конструктор.

[Вернуться к оглавлению](#оглавление)

### Классы

В JavaScript класс – это разновидность функции.

Базовый синтаксис выглядит так:

```JavaScript
class User {

  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }

}

// Использование:
let user = new User("Иван");
user.sayHi();


```

Иногда говорят, что class – это просто «синтаксический сахар» в JavaScript, потому что мы можем сделать всё то же самое без конструкции class:

```JavaScript
// перепишем класс User на чистых функциях

// 1. Создаём функцию constructor
function User(name) {
  this.name = name;
}
// каждый прототип функции имеет свойство constructor по умолчанию,
// поэтому нам нет необходимости его создавать

// 2. Добавляем метод в прототип
User.prototype.sayHi = function() {
  alert(this.name);
};

// Использование:
let user = new User("Иван");
user.sayHi();
```

Однако есть важные отличия:

- Во-первых, функция, созданная с помощью class, помечена специальным внутренним свойством `[[FunctionKind]]:"classConstructor"`. 

Поэтому это не совсем то же самое, что создавать её вручную.

- В отличие от обычных функций, конструктор класса не может быть вызван без `new`.

- Строковое представление конструктора класса в большинстве движков JavaScript начинается с «class …»

- Методы класса являются неперечислимыми. Определение класса устанавливает флаг `enumerable` в `false` для всех методов в "prototype".

И это хорошо, так как если мы проходимся циклом `for..in` по объекту, то обычно мы не хотим при этом получать методы класса.

- Классы всегда используют `use strict`. Весь код внутри класса автоматически находится в строгом режиме.

[Вернуться к оглавлению](#оглавление)

### Promises

Объект Promise (промис) используется для отложенных и асинхронных вычислений.

```JavaScript
let promise = new Promise(function(resolve, reject) {
  // эта функция выполнится автоматически, при вызове new Promise

  // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
  setTimeout(() => resolve("done"), 1000);
});
```

Promise может находиться в трёх состояниях:

- ожидание (pending): начальное состояние, не исполнен и не отклонен.
- исполнено (fulfilled): операция завершена успешно.
- отклонено (rejected): операция завершена с ошибкой.

Когда Promise получает результат, он должен вызвать один из этих колбэков:

`resolve(value)` — если работа завершилась успешно, с результатом `value`.

`reject(error)` — если произошла ошибка, `error` – объект ошибки.

У промиса есть методы:

- `then` 

  Первый аргумент метода `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.
  
  Второй аргумент `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.
  
  ```JavaScript 
    promise.then(
      result => alert(result), // выведет "done!" через одну секунду
      error => alert(error) // не будет запущена
    );
  ```
  Так как методы Promise.prototype.then() и Promise.prototype.catch() сами возвращают промис, их можно вызывать цепочкой.
  
  ```JavaScript
  
  fetch('/article/promise-chaining/user.json')
      .then(function(response) {
        // response.text() возвращает новый промис,
        return response.text();
      })
      .then(function(text) {
        alert(text); // {"name": "iliakan", isAdmin: true}
      });
  ```
- `catch`

  Метод обрабатывает ошибки.
  
  Вызов `.catch(f)` – это сокращённый вариант `.then(null, f)`.
  
- `finally`

  Код внутри этого метода выполнится вне зависимости от ответа промиса (как в `try {...} catch {...} finally {...}`).
  
В классе `Promise` есть 5 статических методов:

- `Promise.all`

    Принимает массив промисов и возвращает новый промис.

    Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.
    
- `Promise.allSettled`
    __Новая возможность языка__. 
    
    `Promise.all` завершается с ошибкой, если она возникает в любом из переданных промисов.

    Метод `Promise.allSettled` всегда ждёт завершения всех промисов. В массиве результатов будет

    `{status:"fulfilled", value:результат}` для успешных завершений,
    
    `{status:"rejected", reason:ошибка}` для ошибок.
    
- `Promise.race` похож на `Promise.all`, но ждёт только первый промис, из которого берёт результат (или ошибку).
- `Promise.resolve(value)` создаёт успешно выполненный промис с результатом `value`.
- `Promise.reject(error)` создаёт промис с ошибкой `error`.
  
[Вернуться к оглавлению](#оглавление)

### Async / Await

Async/Await – специальный синтаксис для работы с промисами.

```JavaScript
async function f() {
  return 1;
}

f().then(alert); // 1
```

Асинхронная функция начинается с ключевого слова `async` и всегда возвращает промис.

Функция `async` может содержать ключевое слово `await`, которое приостанавливает выполнение функции `async` и ожидает ответа от переданного `Promise`.

```JavaScript
async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("готово!"), 1000)
  });

  let result = await promise; // будет ждать, пока промис не выполнится (*)

  alert(result); // "готово!"
}

f();
```

`await` можно использовать только в асинхронных функциях.

[Вернуться к оглавлению](#оглавление)

### Node.js, NPM

__Node.js__ – среда выполнения JavaScript. Она использует управляемую событиями, неблокирующую модель ввода-вывода. Под капотом у Node.js _движок V8_ от Chrome, в 
также такие библиотеки, как __libuv, llhttp, c-ares, OpenSSL, zlib__. Узнать подробнее, для чего они необходимы, можно [здесь](https://nodejs.org/ru/docs/meta/topics/dependencies/). С Node.js связано также понятие __Event Loop (цикл событий)__, которое будет описано ниже.

__NPM__ – менеджер пакетов (библиотек) Node. Содержит огромное количество библиотек, которые можно скачать и использовать в своём проекте одной строчкой в терминале:

```shell
npm install package-name
```

Где `package-name` это название пакета в npm.

[Вернуться к оглавлению](#оглавление)

### Event Loop

Цикл событий (Event Loop) — это то, что позволяет Node.js выполнять неблокирующие операции ввода/вывода (несмотря на то, что JavaScript является однопоточным).

![Event Loop](https://miro.medium.com/max/1400/1*quyTIOs2hioCx1jRQ7-ojw.png)

Все события обрабатываются последовательно и до конца.

Для этого выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.

Список событий, подлежащих обработке, формируют очередь событий. 

Когда стек освобождается, движок может обрабатывать событие из очереди.

[Вернуться к оглавлению](#оглавление)




### React

React – JavaScript-библиотека для создания пользовательских интерфейсов.

Она основана на компонентном подходе. Компоненты позволяют разбить интерфейс на независимые части, про которые легко думать в отдельности. Их можно складывать вместе и использовать несколько раз. В React существуют классовые и функциональные компоненты.

В React используется JSX — расширение языка JavaScript. JSX напоминает язык шаблонов, наделённый силой JavaScript.

В следующем примере мы объявляем переменную `name` и затем используем её внутри JSX, обрамляя фигурными скобками:

```JavaScript

const name = 'Иван-Царевич';
const element = <h1>Здравствуй, {name}!</h1>;

ReactDOM.render(
  element,
  document.getElementById('root')
);

```

React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов.

Например, `class` становится `className` в JSX, а `tabindex` становится `tabIndex`.

В React также используются следующие понятия: пропсы, состояние, жизненный цикл, контекст, рефы и хуки. Они будут рассмотрены ниже.

[Вернуться к оглавлению](#оглавление)



### Props

__Пропсы__ – Объект с JSX-атрибутами и дочерними элементами компонента.

Например, компонент `<Welcome>` выведет «Привет, Алиса» на страницу:

```JavaScript
function Welcome(props) {
  return <h1>Привет, {props.name}</h1>;
}

const element = <Welcome name="Алиса" />;
ReactDOM.render(
  element,
  document.getElementById('root')
);
```

В компонент передаётся значение атрибута `name`, которое хранится в объекте props.

[Вернуться к оглавлению](#оглавление)


### State

Состояние похоже на пропсы, но оно контролируется и доступно только конкретному компоненту.

```JavaScript
class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      <div>
        <h2>Сейчас {this.state.date.toLocaleTimeString()}.</h2>
      </div>
    );
  }
}

ReactDOM.render(
  <Clock />,
  document.getElementById('root')
);
```

Начальное значение состояния задаётся в конструкторе компонента, в данном случае `this.state = {date: new Date()}`.

С помощью метода `this.setState()` происходит обновление состояния:

```JavaScript
this.setState({
  date: new Date()
});
```

Важно знать:

- Не изменяйте состояние напрямую;
- Обновления состояния могут быть асинхронными;
- Обновления состояния объединяются.

[Вернуться к оглавлению](#оглавление)
